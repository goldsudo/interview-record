cookie和session的联系是什么？
session一致性问题？
http的get与post的区别？
TCP的三次握手与四次挥手？
TCP滑动窗口、拥塞控制、慢启动？
TCP连接的本质是什么?
IP路由过程中，上一个包刚被当前路由器转发后，当前路由器挂了，之后会发生什么？TCP链路断了吗？

cookie和session的联系是什么？
答：
	session是一种针对http这种无状态协议的用户身份识别解决方案。
	当用户登录成功后，服务器在本地保存一份该用户的session数据用于之后的身份识别，然后使用set-cookie的方式将该session的唯一id，即session-id返回给客户端，客户端将session-id保存至本地，之后继续发起请求时，将session-id放在header中一起发送，服务端就可以利用这个标识来识别用户的身份了。
	因此总的来说，cookie可以用来实现session。


session一致性问题？
答：
	由于session保存在服务端，所以当服务器集群之后，就要考虑服务器之间的session共享的问题了。
	因为服务器集群意味着需要进行负载均衡，如果用户在a服务器上登录后，下一次请求被转发到b服务器上了，b服务器并不认识这个用户，就会导致要重复登录的问题。
	解决session一致性问题的方法：
	1.客户端存储：
		在cookie通过加密和混淆保存用户信息，而不是在服务端保存，这样每次用户发送请求时服务端都从cookie中解析出来用户的身份信息，就不存在session共享问题了。
		缺点是信息容易暴露，并且每次请求都需要解析cookie，存在性能隐患。
	2.第三方存储：
		将session保存到第三方，比如一个redis服务器中，每次服务器拿到sessinoid，就去redis服务器中获取用户信息，这样也能解决问题。
	3.server间的session共享：
		这个需要靠server间的通信机制来实现，用户的session保存在某个服务器之后，该服务器将session发送给集群中的其他服务器进行共享。
	4.一致性hash的负载均衡：
		由于session一致问题其实是负载均衡导致用户的每次请求不一定落在同一台服务器上导致，那么可以在进行负载均衡时，采用一致性hash的算法，比如利用用户的id来计算hash，把hash对应到具体的服务器上，保证同一个用户的每次请求都被转发到相同的服务器，那么也就不存在session一致性问题了。

http的get与post的区别？
答：
    get和post是http协议中的两种发送请求的方法。
    http是什么？http是基于tcp/ip的关于数据如何在万维网中如何通信的协议。
    http的底层是tcp/ip，因此get和post其实都是tcp链接，其实想要给get加上request body，或者给post带上url参数，在技术上是完全行得通的。
    但是我们往往会去比较get和post方法间的区别，比如下面这些:
        get在浏览器回退时是无害的，而post会再次提交请求；
        get产生的url可以被作为书签，而post不可以；
        get请求会被浏览器主动cache，而post不会，除非手动设置；
        get请求只能进行url编码，而post支持多种编码方式；
        get请求参数会被完整的保留在浏览器历史记录里，而post中的参数不会被保留；
        get请求在url中传送的参数是有长度限制的，而post没有。
        get比post更不安全，因为参数直接暴露在url上，所以不能用来传递敏感信息；
        get中参数通过url传递，而post则将参数放在request body中。

    那么既然技术实现上是没多大的差别的，为什么非要搞出这么多的区别呢？
    原因：
        TCP就像汽车，在网络的世界里，我们使用用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。
        但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。
        为了避免这种情况发生，交通规则HTTP诞生了。
        HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），
        而且要求把传送的数据放在车顶上（url中）以方便记录。
        如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；
        也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。

    而关于参数大小限制的由来则是：
        接着上面的例子，不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。
        但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。
        业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。
        超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略。
        所以，虽然GET可以带request body，也不能保证一定能被接收到哦。
        GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

     GET和POST还有一个重大区别，
        简单的说：
            GET产生一个TCP数据包；POST产生两个TCP数据包。
        长的说：
            对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
            而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
            也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。
            因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？
                1. GET与POST都有自己的语义，不能随便混用。
                2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
                3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。   

TCP的三次握手与四次挥手？
答：
    三次握手：
    为什么是三次握手？而不是2次，或者4次5次？
    是因为三次握手是双方建立稳定通信链接的最小确认次数。
    比如我们和朋友打电话的时候，往往会出现这样的对话：
        A:“hello 能听见吗？”
        B:“hi，我能听见你说话噢，你能听见我说话吗？”
        A:“能听见，那么我们开始说正事吧...”
    光看这个例子可能会人觉得是不是有毛病？电话接通就开始说正事啊，废话那么多干嘛，还来来回回的确认对方听不听得见？
    其实我们考虑这样的情况，假设A给B打电话，B刚接起电话，A就blabla的说了5分钟，然后问b听明白了吗，结果发现b那边早就挂断了。
    又或者，A问B能听见吗之后，B回复A能听见，这个时候假设B不去等待A的第三次确认，那么就可能出现B能听见A说话，而A不能听见B说话的问题。
    这就是不进行双方连接确定的后果。
    而如果进行三次以上的确认的话，又显得太罗嗦了，比如：
        A:“hello 能听见吗？”
        B:“hi，我能听见你说话噢，你能听见我说话吗？”
        A:“能听见，你真的能听见我说话吗”
        B:“你特么有毛病吧，刚才不是说了能听见吗....”
    
    四次挥手：
    为什么断开连接需要是四次的确认？
    这是因为tcp连接是双工的，双工的意思就是连接的两边都可以进行信息的接受和发送，即同时为接收者和发送者。
    既然是双工的，那么就意味着当某一方的数据发送完毕时，不能直接关闭链路，而是需要等待另一方的数据也确认发送完毕了，此时才能彻底断开连接。
    因此，tcp使用四次挥手来确认链路的两边都完成了数据的传输，一个示例的过程如下：
        A:“我这边数据发送完了，我先关闭我这个方向的数据传输了，不过我还能接收你的信息，你赶紧的啊”
        B:“ok，了解了，我这边还有点数据没发完，你等一会”
        （此时A、B间的数据流向就变成单向的了，因为A已经只接收数据而不再传输数据了）
        （过了一段时间后）
        B:“我这边的数据也发送完毕了，我们可以结束这次连接了”
        A:“晓得了，下次再见”

TCP滑动窗口、拥塞控制、慢启动？
答：
    使用这些机制的原因：
        从使用者的角度来看，数据传输当然时每次传输的越多越好，传输的越快越好，巴不得一次性就全部传输完毕。
        但是对于tcp协议来说，它需要考虑更复杂的问题，比如当网络连接不畅通的时候，发送数据包越快，就意味着丢失的数据包就越多，所以数据传输不能一味的追求快速。
        另一方面，服务器处理数据包的能力是有限的，如果每次发来的数据包都特别大，那缓冲区会被顶满，服务器也可能不堪重负，导致数据丢失，因此数据传输也不能一味的追求大量。
    滑动窗口：
        为了解决服务器处理数据包的性能问题，tcp采取了滑动窗口机制，当服务器发现自己的数据处理速度较慢时，可以在以此数据接收确认包中，告诉数据发送方一个缩小后的窗口值。
        发送方接到包后，发现窗口值变小了，就明白接收端的处理能力有限，之后发送的数据量就根据本次传来的窗口值大小来确定。
        等什么时候接收端处理速度上来了，会再通知发送方一个新的更大一点的窗口值，那么发送方又可以一次发送更多的数据了。
        而由于tcp是双向的，因此双方都需要窗口，而且很有可能双方的窗口大小不一致，因为双方的接收和发送的情况是不一样的。
    拥塞控制、慢启动：
        服务器发送数据包，当然是越快越好，但是发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多情况都会导致丢包。线路不好的话，发得越快，丢得越多。
        最理想的状态是，在线路允许的情况下，达到最高速率。但是怎么知道对方线路的理想速率是多少呢？答案就是慢慢试。
        tcp协议为了做到效率与可靠性的统一，设计了一个慢启动机制。开始的时候，发送得比较慢，然后根据丢包的情况，调整速率，如果不丢包，就逐步加快发送速度。
        如果丢包，就降低发送速度。


TCP连接的本质是什么?
答：
    确认对方是否存在的通信机制。

IP路由过程中，上一个包刚被当前路由器转发后，当前路由器挂了，之后会发生什么？TCP链路断了吗？
答：
    tcp链路没断，因为tcp是ip协议的上层，tcp感知不到ip层到底是通过那一条路由线路来传输数据的。
    当某一个路由器挂了之后，该路由器所在路由路线的相关路由节点将会更新自己的本地路由表，然后会将后来的数据包转发到其他正常工作的路由器上去，因此不影响整体的数据传输。